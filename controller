SELECT  f.current_status, n.*, u.username AS username, u2.name AS related_user_name, u2.username AS related_username, t.*, t.content AS tweet_content, n.created_at,
     CASE
     WHEN TIMESTAMPDIFF(SECOND, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(SECOND, t.created_at, NOW()), ' seconds ago')
     WHEN TIMESTAMPDIFF(MINUTE, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(MINUTE, t.created_at, NOW()), ' minutes ago')
     WHEN TIMESTAMPDIFF(HOUR, t.created_at, NOW()) < 24 THEN CONCAT(TIMESTAMPDIFF(HOUR, t.created_at, NOW()), ' hours ago')
     ELSE CONCAT(DATE_FORMAT(t.created_at, '%d'), ' ', DATE_FORMAT(t.created_at, '%M'))
     END as time
     FROM notifications n
     LEFT JOIN users u ON n.user_id = u.id
     LEFT JOIN users u2 ON n.related_user_id = u2.id
     LEFT JOIN followers f ON n.related_user_id = f.follower_id
     LEFT JOIN tweets t ON n.tweet_id = t.id
     WHERE n.user_id = 1 AND n.related_user_id  in (u2.id) AND u2.is_varified = 1 AND f.current_status = 1 AND n.user_id = f.following_id 
     AND n.related_user_id = f.follower_id
     ORDER BY n.created_at DESC;




async function getAllNotifications(loggerId) {
  const [notifications] = await connection.query(
    `SELECT f.current_status, n.*, u.username AS username, u2.name AS related_user_name, u2.username AS related_username, t.*, t.content AS tweet_content, 
    CASE
      WHEN TIMESTAMPDIFF(SECOND, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(SECOND, t.created_at, NOW()), ' seconds ago')
      WHEN TIMESTAMPDIFF(MINUTE, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(MINUTE, t.created_at, NOW()), ' minutes ago')
      WHEN TIMESTAMPDIFF(HOUR, t.created_at, NOW()) < 24 THEN CONCAT(TIMESTAMPDIFF(HOUR, t.created_at, NOW()), ' hours ago')
      ELSE CONCAT(DATE_FORMAT(t.created_at, '%d'), ' ', DATE_FORMAT(t.created_at, '%M'))
    END AS time
    FROM notifications n
    LEFT JOIN users u ON n.user_id = u.id
    LEFT JOIN users u2 ON n.related_user_id = u2.id
    LEFT JOIN followers f ON n.related_user_id = f.follower_id
    LEFT JOIN tweets t ON n.tweet_id = t.id
    WHERE n.user_id = ? AND f.current_status = 1
    ORDER BY n.created_at DESC;`,
    [loggerId]
  );
  return notifications;
}


async function getAllNotifications(userId) {
  const [notifications] = await connection.query(
    `SELECT f.current_status, n.*, u.username AS username, u2.name AS related_user_name, u2.username AS related_username, t.*, t.content AS tweet_content, 
    CASE
      WHEN TIMESTAMPDIFF(SECOND, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(SECOND, t.created_at, NOW()), ' seconds ago')
      WHEN TIMESTAMPDIFF(MINUTE, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(MINUTE, t.created_at, NOW()), ' minutes ago')
      WHEN TIMESTAMPDIFF(HOUR, t.created_at, NOW()) < 24 THEN CONCAT(TIMESTAMPDIFF(HOUR, t.created_at, NOW()), ' hours ago')
      ELSE CONCAT(DATE_FORMAT(t.created_at, '%d'), ' ', DATE_FORMAT(t.created_at, '%M'))
    END as time
    FROM notifications n
    LEFT JOIN users u ON n.user_id = u.id
    LEFT JOIN users u2 ON n.related_user_id = u2.id
    LEFT JOIN followers f ON n.related_user_id = f.follower_id
    LEFT JOIN tweets t ON n.tweet_id = t.id
    WHERE n.user_id = ? AND f.current_status = 1
    ORDER BY n.created_at DESC;`,
    [userId]
  );
  return notifications;
}
async function getVerifiedNotifications(userId) {
  const [notifications] = await connection.query(
    `SELECT f.current_status, n.*, u.username AS username, u2.name AS related_user_name, u2.username AS related_username, t.*, t.content AS tweet_content,
    CASE
      WHEN TIMESTAMPDIFF(SECOND, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(SECOND, t.created_at, NOW()), ' seconds ago')
      WHEN TIMESTAMPDIFF(MINUTE, t.created_at, NOW()) < 60 THEN CONCAT(TIMESTAMPDIFF(MINUTE, t.created_at, NOW()), ' minutes ago')
      WHEN TIMESTAMPDIFF(HOUR, t.created_at, NOW()) < 24 THEN CONCAT(TIMESTAMPDIFF(HOUR, t.created_at, NOW()), ' hours ago')
      ELSE CONCAT(DATE_FORMAT(t.created_at, '%d'), ' ', DATE_FORMAT(t.created_at, '%M'))
    END as time
    FROM notifications n
    LEFT JOIN users u ON n.user_id = u.id
    LEFT JOIN users u2 ON n.related_user_id = u2.id
    LEFT JOIN followers f ON n.related_user_id = f.follower_id
    LEFT JOIN tweets t ON n.tweet_id = t.id
    WHERE n.user_id = ? AND u2.is_verified = 1 AND f.current_status = 1
    ORDER BY n.created_at DESC;`,
    [userId]
  );
  return notifications;
} 
exports.getNotifications = async (req, res) => {
  const loggerId = req.user[0][0].id;

  try {
    // Fetch all notifications
    const allNotifications = await getAllNotifications(loggerId);

    // Fetch verified notifications
    const verifiedNotifications = await getVerifiedNotifications(loggerId);

    // Fetch mention notifications with tweet content
    const mentionNotifications = await getMentionNotifications(loggerId);

    res.status(200).json({
      allNotifications,
      verifiedNotifications,
      mentionNotifications,
    });
  } catch (error) {
    console.error("Error fetching notifications:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};
 
